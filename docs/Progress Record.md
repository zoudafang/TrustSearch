## 3.26
### 进展
1.将最初的代码改为面向对象的形式，并完成优化，目前能够在enclave中正常运行  
2.初步制定了测试方法，说明了数据结构、内存占用等情况  
### 计划
1.规范测量方法  
2.重新配置sgx环境（之前一直用的SIM模式，跑不了HW）  
3.进行测试，并对测试结果进行整理分析。
### 想法
1.测试时，测试集是完全随机查询（可能查不到），还是保证一定能查到的前提下的随机？

## 4.2
### 进展
1.在enclave内进行了测试：  
    ①在不同initialize-size下，运行程序能跑的最小HeapMaxSize（Enclave内存占用），图：X : initialize-size大小，Y ： HeapMaxSize大小  
    ②X : initialize-size大小，Y ：1000次查询耗费时间  
    目前观察到的结论为：  
    ①内存占用与index条目个数基本成正比关系  
    ②根据数据结果，当x为125000~135000左右时（即enclave内存占用在90MB左右），曲线斜率有明显改变，与先前经验吻合；但斜率变化前，x与y也存在跳变关系，即x=100000发生跳变，目前原因尚不明确  
2.初步完成PPT的制作
### 计划
1.再挖掘可以insight的方向  
2.对PPT进行修改完善  
### 想法  
1.相似查询的结果条数和查询时间之间的关系：  
    由于相似查询，本质上是进行精确查询，即把所有可能的条目都查找一次，在特征值段的长度和汉明距离确定的情况下，每次相似查询的查询次数流程是完全一致的，所以最后相似个数与查询时间没有关系

## 4.9
### 进展
##### 1.使用hopscotch map
1.图一：当内存占用在90M以下，initialize size一致时，hopscotch map的内存占用小于unordered map，查询时间小一个数量级。但内存占用存在跳变，原因暂时未知。跳变后，随着x的增大，查询时间下降，初步认为原因为：hopscotch map性质的影响大于SGX的EPC换页开销影响；  
2.图二：随着x的增加，y会在一定范围内保持相对稳定，这与map本身性质相符合  
3.图三：x从百万级增长到千万级，而查询时间保持在几秒的范围内。  
##### 2.改变分段数N
1.当N=2、16时，初始条目为10W，查询1000次的时间分别为21s、40s，这个效果过于差就没有测试该情况下的内存占用。  
2.当N=8时，初始条目相等时，内存占用比N=4的情况高，但查询速度提升了几倍。  
N=8时，数据结构的主要变化为：sub index 特征值段->标识符 : uint16_t -- uint32_t *8 ，相对于N=4时，sub index: uint32_t -- uint32_t *4，标识符的冗余增加
### 计划
1.考虑多线程实现，主要为实现query多线程进行  
2.SGXv2使用  
3.学习c++多线程使用方法
### 想法
1.由于在sub-index中查询时，需要线性地依次查询每个index，那么可以先用多线程分别实现单独的sub-index的查询，将串行处理变成并行处理，提高速度。
